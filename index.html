<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>MutScan presentation</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/deepblue.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1><a target="_blank" href="https://github.com/OpenGene/MutScan/">MutScan</a></h1>
					<h4>fast detection and visualization of target mutations by scanning FASTQ data</h4>
					<p>
						<small>Shifu Chen, Tanxiao Huang, Tiexiang Wen, Hong Li, Mingyan Xu and Jia Gu</small>
					</p>
					<p>
						<small><a target="_blank" href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2024-6">
							BMC Bioinformatics (January 2018) 19:16 DOI 10.1186/s12859-018-2024-6
						</a></small>
					</p>
					<p><small>Speaker: Miguel González Sosa</small></p>
					<p><small><a href="mailto:sosa@uma.es">sosa@uma.es</a></small></p>
				</section>
				<section>
					<h2>What is it for?</h2>
					<ul>
						<li>check whether the given FASTQ files contain some specific mutations.</li>
						<li>visualize and validate them to avoid false positive calling if you have no
							enough confidence with the mutations called by your pipeline.</li>
						<li>check that in a fast way if you worry that your pipeline uses too strict
							filtering and may cause some false negative.</li>
						<li>visualize the called mutation  with its clear pipeup information
							in a more graphic way.</li>
					</ul>
					<aside class="notes">
						El tema es que esto ya se podía hacer antes con un procesado del FASTQ, era una cadena
						de procesado de minimo 3 programas. Esto propicia que los datos se perturben un poco,
						que no sea tan preciso, ya que con el filtrado se pueden perder informacion dando
						falsos negativos. Podia dar falso positivo, hay que tener en cuenta que los programas
						que se usaban no eran especificamente para hacer esta tarea, eran de un proposito
						más general.
						Una ventaja es que el resultado lo podemos ver de forma gráfica con un archivo html que
						se genera automáticamente.
					</aside>
				</section>
				<section>
					<h2>Why use it?</h2>
					<ul>
						<li>open source.</li>
						<li>simple to use.</li>
						<li>multi-threaded.</li>
						<li>can be 50X+ faster than normal pipeline (<a href="https://github.com/lh3/bwa">BWA</a> + <a href="https://github.com/samtools/samtools">Samtools</a> + <a href="https://github.com/broadinstitute/gatk">GATK</a>/<a href="http://varscan.sourceforge.net/">VarScan</a>/<a href="https://github.com/broadinstitute/mutect">Mutect</a>).</li>
						<li>60 built-in cancer-related target mutations to search by default.</li>
					</ul>
					<aside class="notes">
						Es open source: es gratis, tienes a tu disposicion el código y puedes contribuir
						a mejorarlo.
						Simple de usar: el programa en sí no es muy complejo. Así, la interfaz de linea de
						comandos queda muy limpia.
						Multi-hilado: hoy en dia cualquier ordenador tiene mas de un nucleo en su procesador.
						Así que está bien aprovecharlos todos con la proramción concurrente para acelerar el
						proceso.
						Los desarrolladores aseguran que puede ser 50 veces más rápido que el procesado
						convencional, es al que me refería antes.
						Lleva cargadas 60 mutaciones que suelen ser las más buscadas entre las relacionadas
						con el cancer, para que podamos usar el programa sin decirle específicamente
						qué mutaciones queremos encontrar.
					</aside>
				</section>
				<section>
					<h2>Technologies.</h2>
					<ul>
						<li>Coded in C++.
							<img class="fragment current-visible center-image"
							src="lib/resources/proglang.png" alt="Programming languages used.">
						</li>
						<li class="fragment">Depends on <a href="https://zlib.net/"><code>zlib</code></a> library.</li>
						<li class="fragment">Doesn't support Windows natively -> Cygwin-2.6.0/g++ 5.4.</li>
					</ul>
					<aside class="notes">
						Esta escrito en c++. Aunque en github pone que hay una parte en c, es porque
						los headers tienen extensión .h en vez de .hpp y github los considera c.
						Depende únicamente de la librería zlib, que usa para manejar los ficheros
						FASTQ comprimidos. Este tipo de fichero puede pasar de 200 MB comprimido a
						1.3 GB.
						El programa funciona sobre plataformas POSIX, pero en windows podemos usarlo
						con cygwin.
					</aside>
				</section>
				<section>
					<h2>Usage.</h2>
					<pre><code class="bash" data-trim contenteditable>
						mutscan -1 R1.fq.gz -2 R2.fq.gz # pair-end
						mutscan -1 R1.fq.gz # single-end
					</code></pre>
					<p>then open <code>mutscan.html</code> with some browser and <strong>thats all!</strong></p>
					<p>We have more options, though</p>
					<pre><code class="bash" data-trim contenteditable>
						mutscan -1 R1.fq -2 R2.fq -m target.csv # or
						mutscan -1 R1.fq -2 R2.fq -m target.vcf -r hg19.fa
					</code></pre>
					<aside class="notes">
						Cuando secuenciamos con Illumina tenemos dos formas de leer los datos,
						pair-end del que obtenemos los dos extremos de la misma secuencia,
						y single-end del que obtenemos solo un extremo.
						Con eso ya funciona, leeria en busca de las 60 mutaciones que tiene
						ya cargadas por defecto y listo.
						Podemos pasarle un archivo csv con las mutaciones que queremos buscar
						especificamente (ahora enseño un ejemplo), o un vcf, en tal caso
						habria que pasarle el archivo fasta de la secuencia completa, no nos sirve
						el fastaq unicamente.
					</aside>
				</section>
				<section>
					<h4>And more advanced options</h4>
					<pre><code data-trim class="bash" contenteditable="">
usage: mutscan -1 &lt;read1_file&gt; -2 &lt;read2_file&gt; [options]...
options:
  -1, --read1                read1 file name, required
  -2, --read2                read2 file name
  -m, --mutation             mutation file name, can be a CSV format or a VCF format
  -r, --ref                  reference fasta file name (only needed when mutation file is a VCF)
  -h, --html                 filename of html report, default is mutscan.html in work directory
  -t, --thread               worker thread number, default is 4
  -S, --support              min read support required to report a mutation, default is 2.
  -k, --mark                 when mutation file is a vcf file, --mark means only process the records with FILTER column is M
  -l, --legacy               use legacy mode, usually much slower but may be able to find a little more reads in certain case
  -s, --standalone           output standalone HTML report with single file. Don't use this option when scanning too many target mutations (i.e. >1000 mutations)
  -n, --no-original-reads    dont output original reads in HTML and text output. Will make HTML report files a bit smaller
  -?, --help                 print this message
					</code></pre>
				</section>
				<section>
					<h2>Why did I choose this software?</h2>
					<aside class="notes">
						Cuando leí el titulo me sorprendió porque fue leerlo y entender
						de qué se trataba.
						Entré al repositorio, vi que era c++, me gustó, porque
						prefiero los lenguajes de tipado fuerte y estático. Vi que estaba
						bien escrito. Tiene 60 estrellas, que no está mal.
						Lo clone, lo compile, lo probe vi que era facil y me quedé con él.
					</aside>
				</section>
				<section>
					<h2>Code quality.</h2>
					<ul>
						<li><span class="pro">Modular and well-formated code</span>.</li>
						<li><span class="con">Improvable directory hierarchy</span>.</li>
						<li>Documentation: <span class="pro">user manual</span>,
							but maybe <span class="con">there could be more comments in the code</span>.</li>
						<li><i><span class="con">Handmade</span></i> <span class="pro">unit tests</span>: not standarized with any framework.</li>
						<li><span class="con">Tests and functional code are in the same class</span>.</li>
						<li><span class="con">There is no documentation related with the unit tests</span>.</li>
					</ul>
					<aside class="notes">
						El codigo es modular y está bien formateado. Los nombres de la variables, las
						clases y los métodos están bastante correctos. Aunque, eso sí,
						están todos los archivos en la misma carpeta, se podría organizar un poco mejor.
						En cuanto a la documentacion, el manual de usuario esta bien, está casi completo.
						El codigo podría estar un poquito mejor comentado.
						Los test están hechos a mano, que tiene merito, pero con un framework
						podría estar mejor.
						Además, los test están en las mismas clases mezclado con el codigo funcional.
					</aside>
				</section>
				<section>
					<h2>Conclusions.</h2>
					<aside class="notes">
						El software es util, facil de usar, mejor qu elo qu ehabia antes,
						pero el codigo huele un pelin. Hasta ayer pensaba que el programa
						no iba a crecer más y por eso se hizo así: poco documentado,
						pruebas un poco chapuceras... pero vi que ayer habian añadido una nueva
						característica, que es generar el informe en formato JSON.
					</aside>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.configure({ pdfMaxPagesPerSlide: 1 });
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
